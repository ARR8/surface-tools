#!/bin/env python3
import subprocess
import os
import signal
import atexit
import pyudev
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GLib

#####CONFIGURATION#####
SENSORNAME = "accel_3d"
SCREENNAME = "eDP-1"
TOUCHDEVID = "Atmel Atmel maXTouch Digitizer touch"
NOTIFY_ON_LOCK = True
if NOTIFY_ON_LOCK:
    gi.require_version('Notify', '0.7')
    from gi.repository import Notify

#####PROGRAM CODE#####
#Do not change unless you know what you are doing!
XRANDR = "/usr/bin/xrandr"
XSETWACOM = "/usr/bin/xsetwacom"

ROTLOCK = False
PREV_ORIENTATION = ""

def get_orientation(accel_x, accel_y, accel_z):
    abs_accel_x = abs(accel_x)
    abs_accel_y = abs(accel_y)
    abs_accel_z = abs(accel_z)

    if abs_accel_z > 4 * abs_accel_x and abs_accel_z > 4 * abs_accel_y:
        orientation = "flat"
    elif 3 * abs_accel_y > 2 * abs_accel_x:
        if accel_y > 0:
            orientation = "inverted"
        else:
            orientation = "normal"
    else:
        if accel_x > 0:
            orientation = "left"
        else:
            orientation = "right"
    return orientation

def rotate(orientation):
    if orientation in ["normal", "inverted", "left", "right"]:
        subprocess.call([XRANDR, "--output", SCREENNAME, "--rotate",
                         orientation])

        orientation_wacom = {"inverted": "half",
                             "normal": "none",
                             "left": "ccw",
                             "right": "cw"}
        subprocess.call([XSETWACOM, "--set", TOUCHDEVID, "rotate",
                         orientation_wacom[orientation]])

def toggle_rotlock(*args):
    global ROTLOCK
    ROTLOCK = not ROTLOCK
    status_icon = "rotation-locked-symbolic" if ROTLOCK else "rotation-allowed-symbolic"
    status_label = "Rotation locked" if ROTLOCK else "Rotation allowed"

    try:
        n = Notify.Notification.new("Autorotation", status_label, status_icon)
        n.show()
    except NameError:
        pass
    ICON.set_from_icon_name(status_icon)

def check_rotation():
    if not ROTLOCK:
        device = pyudev.Devices.from_path(context, path)
        accel_x = device.attributes.asint("in_accel_x_raw")
        accel_y = device.attributes.asint("in_accel_y_raw")
        accel_z = device.attributes.asint("in_accel_z_raw")


        orientation = get_orientation(accel_x, accel_y, accel_z)

        global PREV_ORIENTATION
        if orientation != PREV_ORIENTATION:
            PREV_ORIENTATION = orientation
            rotate(orientation)
    GLib.timeout_add(1000, check_rotation)

if __name__ == "__main__":
    # Init udev
    context = pyudev.Context()
    for device in context.list_devices(subsystem="iio").match_attribute("name", SENSORNAME): break
    assert device
    path = device.device_path

    # Init GTK
    try:
        Notify.init("autorotate")
    except NameError:
        pass
    ICON = Gtk.StatusIcon.new_from_icon_name("rotation-allowed-symbolic")
    ICON.connect("activate", toggle_rotlock)

    # Init PID
    try:
        RUNDIR = os.environ['XDG_RUNTIME_DIR']
    except KeyError:
        RUNDIR = '/tmp'
    FILENAME = RUNDIR + '/autorotate'
    F = open(FILENAME, 'x')
    F.write(str(os.getpid()))
    F.flush()

    # Init system
    signal.signal(signal.SIGUSR1, toggle_rotlock)
    atexit.register(F.close)
    atexit.register(os.remove, FILENAME)
    try:
        atexit.register(Notify.uninit)
    except NameError:
        pass

    GLib.idle_add(check_rotation)
    Gtk.main()
